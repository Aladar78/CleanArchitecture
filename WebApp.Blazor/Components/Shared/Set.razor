@using System.ComponentModel
@using System.Reflection
@typeparam T
<h3>Table</h3>
<table class="table align-middle table-striped caption-top table-hover">
    <thead class="table-primary">
        <tr>
            @foreach (var coulumn in Columns) {
                <th scope="col">@(GetName(coulumn))</th>
            }
        </tr>
    </thead>
    <tbody>
        @foreach (var row in Rows) {
            <tr>
                @foreach (var column in Columns) {
                    if (Columns.IndexOf(column) == 0) {
                        <th scope="row">@GetValue(column, row)</th>
                    } else {
                        <td>@GetValue(column, row)</td>
                    }
                }
            </tr>
        }
    </tbody>
    <tfoot>
        @* <tr>
        <th scope="col"></th>
        <th scope="col" colspan="3">asdf</th>
        </tr> *@
    </tfoot>
</table>

@code {
    [Parameter] public List<Expression<Func<T, object>>> Columns { get; set; } = [];

    [Parameter] public List<T> Rows { get; set; } = [];

    private string? GetName(Expression<Func<T, object>> expression) {
        var member =
            expression.Body is MemberExpression body ? body.Member :
            expression.Body is UnaryExpression unaryExpression && unaryExpression.Operand is MemberExpression operand ? operand.Member :
            throw new ArgumentException("Expression is not a member access", nameof(expression));

        return member?.GetCustomAttribute<DisplayNameAttribute>()?.DisplayName ?? member?.Name;
    }

    private object GetValue(Expression<Func<T, object>> column, T row) => column.Compile().Invoke(row);
}